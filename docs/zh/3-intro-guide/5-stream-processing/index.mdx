---
title: 流式计算
description: 流式计算的基本概念
---

在时序数据的处理中，经常要对原始数据进行清洗、预处理，再使用时序数据库进行长久的储存。在传统的时序数据解决方案中，常常需要部署 Kafka、Flink 等流处理系统。而流处理系统的复杂性，带来了高昂的开发与运维成本。

TDengine 3.0 的流式计算引擎提供了实时处理写入的数据流的能力，使用 SQL 定义实时流变换，当数据被写入流的源表后，数据会被以定义的方式自动处理，并根据定义的触发模式向目的表推送结果。它提供了替代复杂流处理系统的轻量级解决方案，并能够在高吞吐的数据写入的情况下，提供毫秒级的计算结果延迟。

流式计算可以包含数据过滤，标量函数计算（含UDF），以及窗口聚合（支持滑动窗口、会话窗口与状态窗口），可以以超级表、子表、普通表为源表，写入到目的超级表。在创建流时，目的超级表将被自动创建，随后新插入的数据会被流定义的方式处理并写入其中，通过 partition by 子句，可以以表名或标签划分 partition，不同的 partition 将写入到目的超级表的不同子表。下文以两个案例，介绍流计算的使用方法：

## 示例1

以[智能电表示例数据](../../get-started/package)的表结构为例。企业电表的数据经常都是成百上千亿条的，想要将这些分散、凌乱的数据清洗或转换都需要比较长的时间，很难做到高效性和实时性。以下例子中，通过流计算，可以将电表电压大于 10V 的数据清洗掉，然后以 10 分钟为窗口整合并计算出每个窗口中电流的最大值，最后将结果输出到指定的数据表中:

```sql
CREATE STREAM current_stream
    TRIGGER window_close IGNORE EXPIRED 1
    INTO test.current_stream_output_stb 
    AS 
        SELECT
            _wstart AS wstart,
            _wend AS wend,
            MAX(current) AS max_current,
            COUNT(*) AS point_number
        FROM test.meters WHERE voltage <= 10 INTERVAL(10m);
```

上述命令创建了一个流（Stream），其中，`current_stream` 是流的名称；`TRIGGER ... IGNORE EXPIRED ...` 对流的参数进行了设置；`INTO ...` 定义了输出结果的位置；`AS ...` 通过 SQL 查询语句，定义了流计算的数据源和计算方式，下文对这些内容进行详细介绍：

### 数据源、计算过程

`AS SELECT ...` 通过查询语句定义了流计算的数据源和计算过程；**创建流以后**，所有新写入 `test.meters` 下属子表的数据，都会被按照该 SELECT 语句指定的方式处理，得到计算结果。注意，流式计算不会影响原数据写入 `meters`，流式计算是一个独立的过程。

### 输出计算结果

`INTO test.avg_power` 定义了计算结果的去向：即 `current_stream_output_stb` 超级表，如果超级表不存在，系统会根据 `SELECT ...` 的结果格式创建超级表。流式计算的结果被写入 `current_stream_output_stb` 下属的子表，这些子表由系统自动生成，其生成规则可以进行设置（此功能将在[下一个例子](#result_allocation)中展示）。

### 窗口

示例语句使用了 `INTERVAL(10m)` 窗口查询。由于网络延迟等因素，新写入数据的时间戳可能比已写入数据的时间戳更早（乱序），因此，在理论上，面对源源不断地数据，无法确定某个窗口中的所有数据，是否已被全数写入；无法确定数据的完整性，便无法确定窗口聚合计算的结果是否正确。

在默认情况下，假设一条新数据的时间戳是 t，那么，窗口结束时间在 t 之前的窗口，就会被关闭。如果有新数据的时间戳属于被关闭的窗口，那么该条数据属于过期数据，会被忽略。因此，存在乱序写入时，流计算的结果会丧失一定精度。如需容忍乱序，则需要进行[参数设置](../../sql/stream)，从而减小或避免误差，但这会带来一定的性能开销。

### 触发流计算 {#trigger}

新数据被写入 `test.meters` 后，将在某个时刻触发流计算。流计算的触发时间，由参数 `TRIGGER` 控制。在上例中，`TRIGGER` 的值为 `window_close`，即在时间窗口关闭后，触发流计算，如果窗口未关闭，则新写入的数据并不会马上被执行计算。向表中写入如下数据，并查询计算结果：

```sql
INSERT INTO test.d123 VALUES
    (NOW()+0m, 0.0, 10, 0.5)
    (NOW()+5m, 1.1, 10, 0.5)
    (NOW()+10m, 1.2, 10, 0.5)
    (NOW()+15m, 1.3, 10, 0.5)
    (NOW()+20m, 0.9, 10, 0.5)
    (NOW()+21m, 0.8, 10, 0.5)
    (NOW()+22m, 1.0, 10, 0.5)
    (NOW()+23m, 1.1, 10, 0.5)
    (NOW()+24m, 1.0, 10, 0.5)
    (NOW()+25m, 0.9, 10, 0.5);

SELECT * FROM  test.current_stream_output_stb;
```

执行 SELECT 后，能够看到流计算产生的结果。从 `point_number` 列来看，部分部分写入数据还未被计算，这是因为它们所在的窗口还未关闭。如果需要在数据写入时马上触发计算，可以将 `TRIGGER` 的值设置为 `at_once`，但这样做会带来较大的计算负担。

## 示例2

以[智能电表示例数据](../../get-started/package)的表结构为例。智能电表采集了电流和电压数据，现在需要求出有功功率和无功功率，并以电表名称分组输出到新的数据表中。为此，创建以下流计算：

```sql
CREATE STREAM power_stream
    TRIGGER at_once
    INTO test.power_stream_output_stb
    --highlight-start
        TAGS (loc VARCHAR(100))
        SUBTABLE(CONCAT(loc, "." ,tbn))
    --highlight-end
    AS
        SELECT 
            ts,
            current*voltage*cos(phase) AS active_power,
            current*voltage*sin(phase) AS reactive_power
        FROM test.meters
        PARTITION BY tbname as tbn, location as loc;
```

该语句中的大部分成分，已在上文中介绍过。没有窗口查询的流式计算，只能将 `TRGGER` 设置为 `at_once`。

### 子表的分配和命名规则 {#result_allocation}

流计算的结果被写入一张超级表的下属子表，这些子表由系统创建。每一行计算结果分配到哪一张子表，每张子表如何命名、带有哪些标签，这些规则可以在创建流计算时设置。

在本例中，查询语句的 `PARTITION BY` 对数据进行了分区，每个分区的计算结果会被单独写入到 `power_stream_output_stb` 下属的一个子表中。同时，在指定分区的表达式时，使用 `AS` 定义了 `tbn` 和 `loc` 两个变量名，这两个变量名被用于设置子表的命名和标签规则：`TAGS (...)` 设置了被写入子表的标签，注意，此处的 `loc` 同时决定了标签列的名称和子表的标签值；`SUBTABLE(...)` 设置里子表的命名规则，即“地理位置.数据源子表名”。

写入数据，查看计算结果，以及子表的标签、表名：

```sql
INSERT INTO
    test.d124 VALUES
        (NOW(), 0.0, 10, 0.5)
        (NOW()+5m, 0.1, 10, 0.5)
        (NOW()+10m, 0.2, 10, 0.5)
        (NOW()+15m, 0.3, 10, 0.5)
        (NOW()+20m, 0.4, 10, 0.5)
        (NOW()+25m, 0.5, 10, 0.5)
    test.d125 VALUES
        (NOW(), 0.0, 10, 0.5)
        (NOW()+5m, 0.1, 10, 0.5)
        (NOW()+10m, 0.2, 10, 0.5)
        (NOW()+15m, 0.3, 10, 0.5)
        (NOW()+20m, 0.4, 10, 0.5)
        (NOW()+25m, 0.5, 10, 0.5);

SELECT * FROM  test.current_stream_output_stb;

SELECT table_name, tag_name, tag_value
    FROM information_schema.ins_tags
    WHERE stable_name="power_stream_output_stb" AND db_name="test";
```

最后一条命令查看超级表 `power_stream_output_stb` 下属所有子表的子表名、标签名和标签值。

## 流式计算和数据订阅

流式计算的结果保存在 TDengine 中，应用程序可以通过查询获取。除此之外，还可以使用[数据订阅](../../develop/tmq)，通过类似于 Kafka 的 API，将结果同步到应用端。

## 更多内容

使用流式计算，有许多复杂因素需要考虑，例如，乱序写入、计算触发时间、实时数据与历史数据、数据更新等；如需深入了解流式计算的使用方式，请参考 [SQL 手册](../../sql/stream)。